-- (C) 2013 Pepijn Kokke & Wout Elsinghorst

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module FUN.Analyses.Measure where

import FUN.Analyses.Utils

import Debug.Trace

import Data.Functor
import Data.Monoid
import Data.List

import Data.Map (Map)
import Data.Set (Set)

import Control.Applicative

import qualified Data.List as L
import qualified Data.Map as M
import qualified Data.Set as S
import qualified Data.Foldable as F

type SVar = String
type SCon = String
type BVar = String
type BCon = String

data Scale
  = SVar SVar        -- |Variable measure
  | SCon SCon        -- |Concrete measure       
  | SNil             -- |1
  | SMul Scale Scale -- |s*s
  | SInv Scale       -- |1/s
  deriving (Eq, Ord)

data Base
  = BVar BVar        -- |Variable Base
  | BCon BCon        -- |Concrete Base
  | BNil             -- |No Base
  deriving (Eq, Ord)

instance Show Scale where
  show SNil               = "Unit"
  show (SVar v)           = v
  show (SCon c)           = c 
                                              
  show (SMul SNil b)      = show b
  show (SMul a (SInv b))  = "(" ++ show a ++ "/" ++ show b ++ ")"
  show (SMul (SInv a) b)  = "(" ++ show b ++ "/" ++ show a ++ ")"
  show (SMul a b)         = "(" ++ show a ++ "*" ++ show b ++ ")"
  show (SInv a)           = "(1/" ++ show a ++ ")"
   
data MeasurementError = EmptyError
   deriving Show
   
unifyScale :: Scale -> Scale -> Either MeasurementError SSubst
unifyScale p q = unifyOne $ SMul p (SInv q)
  
unifyOne :: Scale -> Either MeasurementError SSubst
unifyOne p = Right mempty
   
   
instance Show Base where
  show BNil     = "None"
  show (BVar v) = "[" ++ v ++ "]"
  show (BCon c) = c

-- * Constraints
  
data ScaleConstraint
  = ScaleEquality (Set Scale)
  deriving (Eq, Ord)
     
instance Show ScaleConstraint where
  show (ScaleEquality ss) = "equality: " ++ (foldr1 (\x xs -> x ++ " ~ " ++ xs) . map show . S.toList $ ss)
  
data BaseConstraint 
  = BaseEquality (Set Base)             -- |All Bases should unify to the same Base
  | BasePreservation (Base, Base) Base  -- |Generated by addition, see book
  | BaseSelection (Base, Base) Base     -- |Generated by subtraction, see book
  deriving (Eq, Ord)
    
-- |Print the semantics of the corresponding constraint. 
instance Show BaseConstraint where
  show (BaseEquality bs)
    = "equality: " ++ (foldr1 (\x xs -> x ++ " ~ " ++ xs) . map show . S.toList $ bs) 
  show (BasePreservation (x, y) z)
    = "preservation: " ++ show z ++ " = if " ++ show y ++ " = none then " ++ show x 
                                 ++  "; if " ++ show x ++ " = " ++ show y ++ "then none" 
                                 ++  "; else undefined"
  show (BaseSelection (x, y) z)
    = "selection: " ++ show z ++ " = if " ++ show y ++ " = none then " ++ show x
                              ++  "; if " ++ show x ++ " = none then " ++ show y
                              ++  "; else error"


-- |Number of times to repeat the various algorithms which have no guaranteed fixed point.
iterationCount :: Int
iterationCount = 8
                              
-- |Solve Base constraints. The equality case is the same as in the Scale case.
solveBaseConstraints :: Set BaseConstraint -> (BSubst, Set BaseConstraint)
solveBaseConstraints = loop iterationCount mempty where
  loop 0 s0 c0 = (s0, removeSolved c0)
  loop n s0 c0 = 
    let (s1, c1) = solveBaseEquality . unionMap unpackEquality $ c0
        
        (s2, c2) = solveBaseSelection . unionMap unpackSelection $ subst s1 c0
      
        (s3, c3) = solveBasePreservation . unionMap unpackPreservation $ subst (s2 <> s1) c0
                
    in if s1 == mempty &&
          s2 == mempty &&
          s3 == mempty
          then (s0, removeSolved c0)
          else loop (n-1) (s3 <> s2 <> s1 <> s0) (  S.map packEquality     c1
                                                 <> S.map packSelection    c2
                                                 <> S.map packPreservation c3
                                                 )
                                                 
  removeSolved = unionMap (\r -> case r of 
                                   BaseEquality t -> if S.size t == 0 || 
                                                        S.size t == 1 
                                                        then mempty 
                                                        else S.singleton $ BaseEquality t
                
                                   _              -> S.singleton r
                          )
                                              
  unpackEquality  (BaseEquality gr) = singleton gr
  unpackEquality _                  = S.empty
  packEquality = BaseEquality
  
  unpackSelection (BaseSelection (x, y) z) = singleton (x, y, z)
  unpackSelection _                        = S.empty
  packSelection (x, y, z) = BaseSelection (x, y) z
  
  unpackPreservation (BasePreservation (x, y) z) = singleton (x, y, z)
  unpackPreservation _                           = S.empty
  packPreservation (x, y, z) = BasePreservation (x, y) z


instance Solver BaseConstraint BSubst where
  solveConstraints = solveBaseConstraints

type BaseSelection = (Base, Base, Base)
  
-- |Constraints added by addition of two vagriables  
solveBaseSelection :: Set BaseSelection -> (BSubst, Set BaseSelection)
solveBaseSelection = F.foldMap solver where
  solver r@(x, y, BVar z) = if x == BNil
                               then (singleton (z, y), mempty) 
                               else
                            if y == BNil
                               then (singleton (z, x), mempty) 
                               else (mempty, S.singleton r)
  solver r@(BNil, y, z) = case (y, z) of
                            (BVar a,  b) -> (singleton (a, b), mempty)
                            (a,  BVar b) -> (singleton (b, a), mempty)
                            (BNil, BNil) -> (mempty, mempty)
                            (_,       _) -> (mempty, S.singleton r)
  solver r@(x, BNil, z) = case (x, z) of
                            (BVar a,  b) -> (singleton (a, b), mempty)
                            (a,  BVar b) -> (singleton (b, a), mempty)
                            (BNil, BNil) -> (mempty, mempty)
                            (_,       _) -> (mempty, S.singleton r)        

                            
type BasePreservation = (Base, Base, Base)
                                    
-- |Constraints added by subtraction of two variables  
solveBasePreservation :: Set BasePreservation -> (BSubst, Set BasePreservation)
solveBasePreservation = F.foldMap solver where
  solver r@(x, y, BVar z) = if y == BNil
                               then (singleton (z, x), mempty) 
                               else
                            if x == y
                               then (singleton (z, BNil), mempty) 
                               else (mempty, S.singleton r) 
  solver r@(x, BNil, z) = case (x, z) of
                            (BVar a, b) -> (singleton (a, b), mempty)
                            (a, BVar b) -> (singleton (b, a), mempty)
                            (_,      _) -> (mempty, S.singleton r)        

type BaseEquality = Set Base
                           
                          
-- |See @solveScaleEquality for details
solveBaseEquality:: Set BaseEquality -> (BSubst, Set BaseEquality)
solveBaseEquality = loop mempty where
  loop s0 c0 =
    let s1 = F.foldMap solveCons $ subst s0 c0
    in if s1 == mempty
          then (s0, c0)
          else loop (s1 <> s0) (subst s1 c0)
   
  solveCons cs = withSingle (single cons) where
    list = S.toList cs
    
    cons = getBCons list
    vars = getBVars list
    
    single [     ] = case vars of
                          [ ] -> Nothing
                          [x] -> Nothing
                          (x:y:[]) -> Just $ BVar x
    single [  x  ] = Just $ x
    single (x:y:_) = Nothing
    
    withSingle (Just  x) = foldr (\v m -> m <> singleton (v,x)) mempty vars
    withSingle (Nothing) = mempty
    
  getBCons = filter isBCon where
    isBCon  (BNil    ) = True
    isBCon  (BCon _  ) = True
    isBCon  (BVar _  ) = False
    
  getBVars = concatMap $ \t ->
    case t of BVar v -> [v]
              _      -> [ ]

              
printScaleInformation :: Set ScaleConstraint -> String
printScaleInformation m =
  let prefix = "{\n"
      content = S.foldr (\x xs -> "  " ++ show x ++ "\n" ++ xs) "" m
      suffix = "}"
  in prefix ++ content ++ suffix


printBaseInformation :: Set BaseConstraint -> String
printBaseInformation m = 
  let prefix = "{\n"
      content = S.foldr (\x xs -> "  " ++ show x ++ "\n" ++ xs) "" m
      suffix = "}"
  in prefix ++ content ++ suffix
  
-- * Scale Substitutions
    
instance (Subst e Scale) => Subst e ScaleConstraint where
  subst m (ScaleEquality ss) = ScaleEquality $ subst m ss

newtype SSubst = SSubst { 
    getSSubst :: Map SVar Scale
  } deriving (Eq, Ord, Show)

instance Subst SSubst SSubst where
  subst m (SSubst s) = SSubst (subst m s)
  
instance Subst SSubst Scale where
  subst m v@(SVar n)   = M.findWithDefault v n (getSSubst m)
  subst m v@(SCon _)   = v
  subst m   (SMul a b) = SMul (subst m a) (subst m b)
  subst m   (SInv a)   = SInv (subst m a)
  subst m v@_          = v
   
instance Monoid SSubst where
  s `mappend` t = SSubst $ getSSubst (subst s t) `M.union` getSSubst s 
  mempty        = SSubst $ M.empty
                
instance Singleton SSubst (SVar,Scale) where
  singleton (k,a) = SSubst (M.singleton k a)
  
-- * Base Substitutions
  
instance (Subst e Base) => Subst e BaseConstraint where
  subst m (BaseEquality ss)           = BaseEquality $ subst m ss
  subst m (BasePreservation (x, y) z) = BasePreservation (subst m x, subst m y) (subst m z)
  subst m (BaseSelection (x, y) z)    = BaseSelection (subst m x, subst m y) (subst m z)

newtype BSubst = BSubst { 
  getBSubst :: Map BVar Base
  } deriving (Eq, Ord, Show)

instance Subst BSubst BSubst where
  subst m (BSubst s) = BSubst (subst m s)
  
instance Subst BSubst Base where
  subst m v@(BVar n) = M.findWithDefault v n (getBSubst m)
  subst m v@(BCon _) = v
  subst m BNil       = BNil

instance Subst BSubst (Base, Base, Base) where
  subst m (a, b, c) = (subst m a, subst m b, subst m c)
  
instance Monoid BSubst where
  s `mappend` t = BSubst $ getBSubst (subst s t) `M.union` getBSubst s
  mempty        = BSubst $ mempty
  
instance Singleton BSubst (BVar, Base) where
  singleton (k,a) = BSubst (M.singleton k a)
